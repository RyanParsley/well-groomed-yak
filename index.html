<!DOCTYPE html>
<html>
  <head>
    <title></title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
    <meta property="og:title" content=""/>
    
    
    
    
    
    
    <link rel="stylesheet" href="assets/style/style.css" />
    
    <style type="text/css">
      body {
  font-family: 'Avenir Next', 'Hiragino Kaku Gothic ProN', 'Meiryo', 'メイリオ', sans-serif;
}
h1, h2, h3 {
  font-weight: bold;
}
.remark-code,
.remark-inline-code {
  font-family: 'Menlo', 'Monaco', 'Courier new', monospace;
}

.remark-slide-content.inverse {
  color: #f3f3f3;
  background-color: #272822;
}

      @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(-360deg); } }
    </style>
  </head>
  <body>
    <textarea id="source" style="display: none">class: middle, center, title

# The Well Groomed Yak

## Thoughts on delightful productivity

### Ryan Parsley and Craig McCoy

#### 2024-02-26

???

Beyond the realm of standard Integrated Development Environments, this presentation uncovers hidden gems like shell scripts and multiplexers, proving that sometimes, the best solutions aren't the most obvious ones. We'll explore how simple tools can turn repetitive tasks into quick wins, saving time and sanity. This isn't just about new tools; it's about rethinking how we approach those pesky, recurring coding problems. Discover how stepping outside the IDE can lead to smarter, more efficient coding practices.

---

background-image: url(./assets/yakShaving.png)
background-size: 450px auto

# Yak Shaving!?

???

You signed up for a presentation with "yak shaving" in the title. Thank you. If you are not familiar with the phrase, that's at least twice as weird, but just to make sure we're all on the same page.

---

class: middle, center

> "Any apparently useless activity which, by allowing one to overcome intermediate difficulties, allows one to solve a larger problem." -[wiktionary](https://en.wiktionary.org/wiki/yak_shaving)

???

This is a pretty good definition. The key point is it appears to be useless while it's actually critical to success.

I don't know about "apparently useless". I guess _apparently_ is a fine word so long as you know know it's inacurate. Did you play Breath of the Wild or Tears of the Kingdom? Software development is a lot like that.

Sure, the epic is about defeating ganon, but you're gonna have to farm a lot of apples along the way. You can't do the main quest without some number of sidequests. And you may find you spend a disproportionate amount of time on the sidequests... That's the gig.

To me, all the auxillary or meta work that you do so you can actually do what people ask for is the yak shaving.

This should be seen as potentially bad, but it's kind of like tech debt in that you need to make peace with a certain amount of it and understand that everything comes at a cost. Be mindful of that.

---

# Things Developers tend to agree on

1. Repeating yourself is bad
2. Configuration as code is good
3. Bad abstraction is worse than no abstraction
4. Optimization is good
5. Premature optimization is bad
6. This meeting should have been an email
7. Repeating yourself is bad
8. Clean Code is an overrated book
9. Neovim is the best text editor of all time
10. Nothing matters less than whitespace but you will go fisticuffs over 8 space tabs

???

Maybe you don't agree with all of those points. Typography is actually very important.

We have subjective differences but we share a lot of values. This is particularly evident when it comes to the importance/value of efficiency. No one is going to champion "I don't value time". We don't always see eye to eye on which activities are valuable though.

As such this presentation is less about trying to prescribe tools to you and more about drawing your attention to inefficiency you may take for granted.

---

# Automate all the things

- macros (keyboard maestro)
- window management
- snippets in your editor and beyond
- templates
- shell aliases
- shell scripts
- language scripts (rust, python)
- dotfiles

???

When I talk about automation, I mean anytime you save a few keystrokes by using technology.

I'll count copy/paste as a crude form of automation, but I know you're better than that.

Don't throw your hammer away because you get a drill, there will always be nails.



---

background-image: url(./assets/optimization.png)
background-size: auto 500px
background-position: 75% 80%

# Automate all the things

## but not too soon

???

DRY was here first, but there's a lot to be said for the tempered wisdom of WET

Write
Everything
Twice

Premature optimization is bad. Bad in app architecture and bad in the broader persuit of productivity. 

Why? Because you are good at a lot of things, but predicting the future isn't one of them.

---

background-image: url(./assets/evolutionOfAutomation.jpg)
background-size: auto 450px

# Evolution of Productivity

???

Natural selection is considered the main mechanism that causes evolution.

Delight & Productivity should drive the evolution of your tools.

Replacing mindless monotony with a delightful script is a win even if the script doesn't save you a tone of time. 

You're more engaged with the task at hand, you probably understand it better. 

Just don't go overboard and remember that all of this is in service of shipping code people actually asked for.

---

background-image: url(./assets/gwh.jpeg)
background-size: auto 450px
background-position: 50% 80%

# Delightful Productivity

## the good stuff

???

When you can have both, that's the good stuff.

---

class: middle, center

# Recognition

## out performs Precognition

???

I assert that the skillful persuit of automation is a game about pattern recognition, not precognition. Be frustrated by tedium.

---

class: middle, center

# A lot of tasks are _just_ text manipulation

???

Maybe a good time to talk about how tabular data could not be in excel, but frontmatter in markdown or nod to dataview in obsidian.

---

class: middle, center

# Assume there's a better way

???

As knowledge workers, we mostly deal with constructs of our own design. Code is not limited by physics. You don't need to work by a fire to write code about blacksmithing. If parts of your job feel bad, consider part of your job is to fix that

Anecdote about making throw away apps for a startup and getting good at bootstrapping apps such that the tooling to generate apps was my "product".

---

background-image: url(./assets/efficiency.png)
background-size: 450px auto

# Be mindful of diminishing&nbsp;returns

???

Sometimes there's a better way and you shouldn't chase it.

You won't always be able to quantify time saved, but be aware of that critical point where you're simply trading one class of busy work for another.

I say about prettier that the only thing worst than prettier's defaults is not using prettier. Talking about whitespace on the internet is a fine hobby if you're into that, but it's a colossal waste of time in a PR.

Wire up prettier.

If you feel passionate about it's defaults, configure them. If you don't feel passionate enough to learn how to configure prettier, you don't feel passionate enough to complain about it.

---

background-image: url(./assets/productivityTradeoffs.excalidraw.png)
background-size: 600px auto

# Be mindful of tradeoffs

???

The small sharp tools at the top of this chart are sort of the standard lib of productivity. You can count on them being on most computers or it's trivial to assure that they are.

As you move down to the yellow zone, you're mostly just abstracting over the previous toolset. Nx generate is a presumptuous set of opinions to turbo charge templates.

Being tightly coupled is often assumed to be bad, but it can be very powerful... but at a cost.

Every time you have gained value from a tool is not rendered null should you no longer be able to use it

All that benefit from your past is in the bank and changing your mind robs you of nothing.

---

# Problem

## You need to spin up a bunch of tasks when you work on a project

???

Project is vague here.

Maybe it's "write code for an app".

Maybe it's "document something".

Maybe it's collaborate on a slide deck for a presentation.

Are you context switching to make clacky sounds for a new reason... that counts.

---

class: middle, center

# Solution

## terminal multiplexer

???

For me, this context switching screams "multiplexor" and I'm going to walk you through what I mean by that.

Maybe you have a cool plugin for VS Code.
Maybe you have a powershell script.

I like "Zellij"

---

background-image: url(./assets/wat.gif)
background-size: 350px auto

# Multiplexer!?

???

Historically, a terminal multiplexer was a killer app to help with remoting into a server.They allow you to run multiple Linux programs over a single connection. I'm more into the the mulitple programs bit and less about the connection. I use them locally to automate spinning up processes I need to start my day.

A couple of lines of yaml/json or toml in your home directory and a few keystrokes can drop you into a given directory, open your editor, spin up a dev server and start watching code changess to fire off tests.

Tmux is by far the most popular solution for this. I've used it for years happily, but currently I'm using an alternative called Zellij. Either is great!

---

# Demo: Multiplexor

???

As you can see here, I type a command and I'm ready to write this slide deck. I launch vim, but you can launch your editor of choice just as easy. Note the tab has a dev server hosting the deck locally.

---

# Problem

## Who is responsible for install!?

???
One bit of friction with anytime installs is communicating what's changing and who is on the hook for validation. For a while, Match had a considerable amount of legwork daily by the build master and build manager to mitigate risk and communicate changes to production.

The build master was on the hook to do more or less the same task every day to facilitate communication around changes. This looks like a job for robots!

---

background-image: url(./assets/whoIsResponsible.png)
background-size: 450px auto

# Solution

## Shell Script in the pipeline

???
The final result looks like this. Every successful build has a chunk in the logs that lists the developers that commited code since the last deploy.

This started off with me automating the process for myself. If I was going to be occasionally responsible for this context, I wanted to get it easily and fast. Once I wrote a shell script that did what I needed locally, It made sense to remove myself as a bottleneck for this data.

At first, I taught some devs how to run the script, but then it became obvious that there was a lot of value in having this information associated with any given build.

Why stop at shell script?

It was "good enough". You got to know when to hold them and know when to fold them.

There is a trusted source of truth bound to every build. We _could_ do more. We could automate a daily email. We could drop the log into a team chat. We have collected the data and compiled it into something human readable. Should we need more, this is ready to evolve further.

---

background-image: url(./assets/commitsInProd.png)
background-size: 750px auto

# Implementation

???

A thing that took hours a day to collect and communicate is added to every build in about a second

---

background-image: url(./assets/releaseChecklistTime.png)
background-size: 450px auto

# Checklist

## Pipeline performance impact

???

The return on investment for such a change is exponential.

---

# Problem

## inconsistent node versions

???

There's a class of issues that come up when the same version of node isn't used.

This could range from false positive and negative builds, tests, and failures locally or in pipelines.

---

background-image: url(./assets/nvmrc.png)
background-size: 97%

# Solution

## .nvmrc -> nvm -> pipeline yml -> automated

???
It starts with recognition (people not using same versions of node, struggles, ci/cd, etc)

Someone writes down which version to use in wiki and communicates it to the team _see the copy and paste!_

You move to codifying version in .nvmrc 

Everyone uses version locally with command (hey run nvm use! hey did you run nvm use?)

(use version in Ci/CD) (finally we have parity! we could stop here!)

automatically switch locally when changing folders (I Switch projects often)

---

background-image: url(./assets/nvmrc-combined.png)
background-size: 850px auto

???

Think about how we evolved in this example.

How did recognition drive our evolution?

---

# References

- [Recognition Template](./assets/problem-tracking.md)
- [Recognition Template - Obsidian](./assets/problem-tracking-obsidian.md)
- [Zellij](https://zellij.dev/)
- [tmux](https://sass-lang.com/documentation/variables)
- [Stow](https://www.gnu.org/software/stow/manual/stow.html)
- [Nushell](https://www.nushell.sh/)
- [Smug](https://github.com/ivaaaan/smug)
- [mise](https://mise.jdx.dev/getting-started.html)
- [WezTerm](https://wezfurlong.org/wezterm/index.html)
- [Neovim](https://neovim.io/)
</textarea>
    <div style="z-index: -1; position: fixed; display: flex; align-items: center; gap: 4px;">
      <svg style="animation: spin 1s linear infinite; width: 18px; height: 18px;" xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-refresh" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
        <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
        <path d="M20 11a8.1 8.1 0 0 0 -15.5 -2m-.5 -4v4h4" />
        <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4" />
      </svg>
      <span>loading...</span>
    </div>
    <script src="remark.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.9.2/mermaid.min.js"></script>
    
    <script>
      window.slideshow = remark.create({})
    </script>
    
    <script>
      mermaid.initialize({startOnLoad:true});
      ;window.LiveReloadOptions = {
        host: 'localhost',
        port: '35729'
      };
    </script>
  </body>
</html>
